let test_u8_repr : u8.Repr -> U8 = fun x => x;
let test_u16be_repr : u16be.Repr -> U16 = fun x => x;
let test_u16le_repr : u16le.Repr -> U16 = fun x => x;
let test_u32be_repr : u32be.Repr -> U32 = fun x => x;
let test_u32le_repr : u32le.Repr -> U32 = fun x => x;
let test_u64be_repr : u64be.Repr -> U64 = fun x => x;
let test_u64le_repr : u64le.Repr -> U64 = fun x => x;
let test_s8_repr : s8.Repr -> S8 = fun x => x;
let test_s16be_repr : s16be.Repr -> S16 = fun x => x;
let test_s16le_repr : s16le.Repr -> S16 = fun x => x;
let test_s32be_repr : s32be.Repr -> S32 = fun x => x;
let test_s32le_repr : s32le.Repr -> S32 = fun x => x;
let test_s64be_repr : s64be.Repr -> S64 = fun x => x;
let test_s64le_repr : s64le.Repr -> S64 = fun x => x;
let test_f32be_repr : f32be.Repr -> F32 = fun x => x;
let test_f32le_repr : f32le.Repr -> F32 = fun x => x;
let test_f64be_repr : f64be.Repr -> F64 = fun x => x;
let test_f64le_repr : f64le.Repr -> F64 = fun x => x;

let test_repeat_len8 : fun n f -> (repeat_len8 n f).Repr -> Array8 n f.Repr = fun _ => fun _ => fun x => x;
let test_repeat_len16 : fun n f -> (repeat_len16 n f).Repr -> Array16 n f.Repr = fun _ => fun _ => fun x => x;
let test_repeat_len32 : fun n f -> (repeat_len32 n f).Repr -> Array32 n f.Repr = fun _ => fun _ => fun x => x;
let test_repeat_len64 : fun n f -> (repeat_len64 n f).Repr -> Array64 n f.Repr = fun _ => fun _ => fun x => x;

let test_repeat_until_end : fun f -> (repeat_until_end f).Repr -> Array f.Repr = fun _ x => x;

let test_limit8 : fun n f -> (limit8 n f).Repr -> f.Repr = fun _ _ x => x;
let test_limit16 : fun n f -> (limit16 n f).Repr -> f.Repr = fun _ _ x => x;
let test_limit32 : fun n f -> (limit32 n f).Repr -> f.Repr = fun _ _ x => x;
let test_limit64 : fun n f -> (limit64 n f).Repr -> f.Repr = fun _ _ x => x;

let test_link : fun pos f -> (link pos f).Repr -> Ref f = fun _ _ x => x;
let test_deref : fun f (ref : Ref f) -> (deref ref).Repr -> f.Repr = fun _ _ x => x;
let test_stream_pos : stream_pos.Repr -> Pos = fun x => x;
let test_succeed : fun (A : Type) (x : A) -> (succeed x).Repr -> A = fun _ _ x => x;
let test_fail : fail.Repr -> Void = fun x => x;
let test_unwrap : fun A (opt_a : Option A) -> (unwrap opt_a).Repr -> A = fun _ _ x => x;

Type
